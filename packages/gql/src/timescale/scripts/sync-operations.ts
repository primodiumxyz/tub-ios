import { existsSync, mkdirSync, readdirSync, readFileSync, writeFileSync } from "fs";
import path, { dirname } from "path";
import { fileURLToPath } from "url";
import pg from "pg";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const LOCAL_URL = "postgres://tsdbadmin:password@localhost:5433/indexer";
const LOCAL_PASSWORD = "password";

interface Config {
  endpoint?: string;
  adminSecret?: string;
}

async function getClient(config?: Config) {
  const connectionString = config?.endpoint ?? LOCAL_URL;
  const password = config?.adminSecret ?? LOCAL_PASSWORD;

  return new pg.Client({
    connectionString,
    password,
    ssl: connectionString.includes("cloud.timescale.com") ? { rejectUnauthorized: true } : undefined,
  });
}

async function main() {
  const args = process.argv.slice(2);
  const config: Config = {};

  for (let i = 0; i < args.length; i += 2) {
    if (args[i] === "--endpoint") config.endpoint = args[i + 1];
    if (args[i] === "--admin-secret") config.adminSecret = args[i + 1];
  }

  const client = await getClient(config);
  await client.connect();

  try {
    // 1. Apply SQL functions to TimescaleDB
    const dirs = ["queries", "mutations"];
    const operations: { name: string; type: "query" | "mutation" }[] = [];

    for (const dir of dirs) {
      const operationsDir = path.resolve(__dirname, `../${dir}`);
      const files = readdirSync(operationsDir).filter((f) => f.endsWith(".sql"));

      for (const file of files) {
        const sql = readFileSync(path.resolve(operationsDir, file), "utf8");
        await client.query(sql);
        operations.push({
          name: file.replace(".sql", ""),
          type: dir === "queries" ? "query" : "mutation",
        });
      }
    }

    // Ensure metadata directories exist
    const metadataDir = path.resolve(__dirname, "../../../metadata");
    const databasesDir = path.resolve(metadataDir, "databases");
    const graphqlDir = path.resolve(__dirname, "../../../src/graphql");

    if (!existsSync(metadataDir)) {
      mkdirSync(metadataDir, { recursive: true });
    }
    if (!existsSync(databasesDir)) {
      mkdirSync(databasesDir, { recursive: true });
    }
    if (!existsSync(graphqlDir)) {
      mkdirSync(graphqlDir, { recursive: true });
    }

    // Create or update the TimescaleDB metadata
    const metadata = {
      name: "timescaledb",
      kind: "postgres",
      configuration: {
        connection_info: {
          database_url: { from_env: "TIMESCALE_DATABASE_URL" },
        },
      },
      tables: operations
        .filter((op) => op.type === "query")
        .map((op) => ({
          name: op.name,
          schema: "public",
        })),
      functions: operations
        .filter((op) => op.type === "mutation")
        .map((op) => ({
          name: op.name,
          schema: "public",
        })),
    };

    const metadataPath = path.resolve(databasesDir, "timescaledb.yaml");
    writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));
    console.log("✨ TimescaleDB metadata updated successfully");

    // Generate TypeScript operations file
    const operationsPath = path.resolve(graphqlDir, "timescale-operations.ts");
    const operationsContent = `// Generated by sync-operations.ts
export const TimescaleOperations = {
  queries: ${JSON.stringify(
    operations.filter((op) => op.type === "query").map((op) => op.name),
    null,
    2,
  )},
  mutations: ${JSON.stringify(
    operations.filter((op) => op.type === "mutation").map((op) => op.name),
    null,
    2,
  )}
} as const;

export type TimescaleQueries = typeof TimescaleOperations.queries[number];
export type TimescaleMutations = typeof TimescaleOperations.mutations[number];
`;

    writeFileSync(operationsPath, operationsContent);
    console.log("✨ TimescaleDB operations file generated successfully");
  } catch (error) {
    console.error("Error:", error);
    throw error;
  } finally {
    await client.end();
  }
}

main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
