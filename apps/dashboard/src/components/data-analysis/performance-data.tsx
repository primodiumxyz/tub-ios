import { useMemo, useState } from "react";
import { formatDistance } from "date-fns";

import { PerformanceChart } from "@/components/data-analysis/performance-data-chart";
import { HintTooltip } from "@/components/HintTooltip";
import { Button } from "@/components/ui/button";
import { Table, TableBody, TableCaption, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { useAnalyticsParams } from "@/hooks/use-analytics-params";
import { useDataAnalysisData } from "@/hooks/use-data-analysis";
import { useTrackerParams } from "@/hooks/use-tracker-params";
import { AFTER_INTERVALS, DEFAULT_SORT_BY, SortByMetric, TOP_N_TOKENS } from "@/lib/constants";
import { TokenStats } from "@/lib/types";
import { getTokensPerformanceStats } from "@/lib/utils";

export const PerformanceBasePeriodDataTable = ({ chartWidth }: { chartWidth: number }) => {
  const { data, error, loading } = useDataAnalysisData();
  const { from, to } = useAnalyticsParams();
  const { timespan } = useTrackerParams();
  const [sortBy, setSortBy] = useState<SortByMetric>(DEFAULT_SORT_BY);

  const stats = useMemo(() => (data ? getTokensPerformanceStats(data, sortBy) : undefined), [data, sortBy]);

  const chartData = useMemo(() => {
    if (!stats) return [];

    return Array.from(stats.byInterval.entries())
      .map(([intervalStart, stats]) => ({
        interval_start: new Date(intervalStart),
        stats: stats.byAfterInterval,
      }))
      .sort((a, b) => a.interval_start.getTime() - b.interval_start.getTime());
  }, [stats]);

  if (loading && !stats)
    return (
      <div className="w-full text-sm text-muted-foreground">
        <p>This might take a while...</p>
        <p>
          Querying tokens performance for each {timespan} iteration over a period of {formatDistance(from, to)}, during
          the following intervals: {AFTER_INTERVALS.map((interval) => interval).join(", ")}.
        </p>
      </div>
    );
  if (error) return <div className="w-full text-sm text-muted-foreground">{error}</div>;
  if (!stats) return <div>No data</div>;

  return (
    <div className="w-full flex flex-col gap-8 items-start">
      <div className="flex gap-2 items-center">
        <span className="text-sm text-muted-foreground">Sort by:</span>
        <Button
          variant={sortBy === SortByMetric.TRADES ? "secondary" : "ghost"}
          size="sm"
          onClick={() => setSortBy(SortByMetric.TRADES)}
        >
          Trades
        </Button>
        <Button
          variant={sortBy === SortByMetric.VOLUME ? "secondary" : "ghost"}
          size="sm"
          onClick={() => setSortBy(SortByMetric.VOLUME)}
        >
          Volume
        </Button>
      </div>
      <div className="relative w-full">
        <GlobalStatsTable stats={stats.global} sortBy={sortBy} />
        <HintTooltip
          content={
            <div>
              <p>
                These statistics are generated by filtering tokens over an interval of {timespan}, sorting them by{" "}
                {sortBy.toLowerCase()}, and using the top {TOP_N_TOKENS} tokens.
              </p>
              <p>
                We calculate their performance during the next {AFTER_INTERVALS.map((interval) => interval).join(", ")}{" "}
                after the initial filtering, and repeat this process for each interval iteration over the selected
                period.
              </p>
            </div>
          }
        />
      </div>
      <div className="relative w-full">
        <PerformanceChart data={chartData} width={chartWidth} height={400} />
        <HintTooltip content="Average increase percentage for each interval, as presented in the table above." />
      </div>
    </div>
  );
};

export const GlobalStatsTable = ({ stats, sortBy }: { stats: TokenStats; sortBy: SortByMetric }) => {
  return (
    <Table className="text-start">
      <TableCaption>
        Performance of top 10 tokens by {sortBy.toLowerCase()} during the next intervals across{" "}
        {stats.tokenCount.toLocaleString()} tokens
      </TableCaption>
      <TableHeader>
        <TableRow>
          <TableHead>Next</TableHead>
          <TableHead>Avg. increase %</TableHead>
          <TableHead>Min increase %</TableHead>
          <TableHead>Max increase %</TableHead>
          <TableHead>Avg. trades</TableHead>
          <TableHead>Min trades</TableHead>
          <TableHead>Max trades</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {stats.byAfterInterval.map((interval, index) => (
          <TableRow key={index}>
            <TableCell className="font-medium">{AFTER_INTERVALS[index]}</TableCell>
            <TableCell>{interval.increasePct.avg.toLocaleString()}%</TableCell>
            <TableCell>{interval.increasePct.min.toLocaleString()}%</TableCell>
            <TableCell>{interval.increasePct.max.toLocaleString()}%</TableCell>
            <TableCell>{interval.trades.avg.toLocaleString()}</TableCell>
            <TableCell>{interval.trades.min.toLocaleString()}</TableCell>
            <TableCell>{interval.trades.max.toLocaleString()}</TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
};
